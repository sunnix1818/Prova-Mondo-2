<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<title>Control</title>

<script src="https://d3js.org/d3.v7.min.js"></script>

<style>
html,body{margin:0;padding:0;overflow:hidden;background:#020617;font-family:system-ui}
canvas{display:block}
#ui,#menu{
  position:fixed;
  background:rgba(0,0,0,.85);
  color:white;
  border-radius:12px;
  padding:14px;
}
#ui{top:10px;left:10px;min-width:230px}
#menu{
  inset:0;
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  z-index:10;
}
button{
  width:200px;
  margin:6px;
  padding:10px;
  border:none;
  border-radius:8px;
  font-size:15px;
  cursor:pointer;
  background:#2563eb;
  color:white;
}
</style>
</head>

<body>

<div id="menu">
  <h2>CONTROL</h2>
  <button onclick="startGame('europe')">üá™üá∫ Europa</button>
  <button onclick="startGame('world')">üåç Mondo</button>
</div>

<canvas id="map"></canvas>

<div id="ui">
  <div id="info">Scegli modalit√†</div>
  <button id="endTurn">Fine turno</button>
</div>

<script>
/* ===== BASE ===== */
const canvas=document.getElementById("map");
const ctx=canvas.getContext("2d");
const info=document.getElementById("info");
const endTurnBtn=document.getElementById("endTurn");

function resize(){
  canvas.width=innerWidth;
  canvas.height=innerHeight;
}
resize();
addEventListener("resize",resize);

/* ===== PROIEZIONE ===== */
const projection=d3.geoMercator()
  .translate([canvas.width/2,canvas.height/2]);

const path=d3.geoPath(projection,ctx);

/* ===== ZOOM ===== */
let transform=d3.zoomIdentity;
d3.select(canvas).call(
  d3.zoom().scaleExtent([1,10]).on("zoom",e=>{
    transform=e.transform;
    draw();
  })
);

/* ===== GAME ===== */
let regions=[];
let selected=null;
let fromRegion=null;
let mode="";

const players=[
  {name:"Player",color:"#2563eb",ai:false},
  {name:"AI",color:"#16a34a",ai:true}
];
let currentPlayer=0;

const game={regions:{}};

/* ===== START ===== */
function startGame(m){
  mode=m;
  document.getElementById("menu").style.display="none";

  if(mode==="europe"){
    projection.center([15,55]).scale(650);
    loadMap("https://raw.githubusercontent.com/leakyMirror/map-of-europe/master/GeoJSON/europe.geojson");
  }else{
    projection.center([0,20]).scale(280);
    loadMap("https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson");
  }
}

/* ===== LOAD MAP ===== */
function loadMap(url){
  fetch(url).then(r=>r.json()).then(data=>{
    regions=data.features;
    initRegions();
    draw();
  });
}

function initRegions(){
  game.regions={};
  regions.forEach(r=>{
    const name=r.properties.NAME||r.properties.ADMIN||r.properties.name;
    r._name=name;
    game.regions[name]={
      owner:players[Math.floor(Math.random()*players.length)],
      troops:Math.floor(Math.random()*3)+1,
      neighbors:[]
    };
  });
  calcAdjacency();
}

/* ===== ADIACENZE ===== */
function calcAdjacency(){
  for(let a of regions){
    for(let b of regions){
      if(a===b) continue;
      if(d3.geoIntersects(a,b)){
        game.regions[a._name].neighbors.push(b._name);
      }
    }
  }
}

/* ===== DRAW ===== */
function draw(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="#1e40af";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.setTransform(transform.k,0,0,transform.k,transform.x,transform.y);

  regions.forEach(r=>{
    const state=game.regions[r._name];
    ctx.beginPath();
    path(r);
    ctx.fillStyle=state.owner.color;
    ctx.fill();
    ctx.strokeStyle="#000";
    ctx.lineWidth=0.6;
    ctx.stroke();

    const c=path.centroid(r);
    ctx.fillStyle="#fff";
    ctx.font="10px system-ui";
    ctx.textAlign="center";
    ctx.fillText(state.troops,c[0],c[1]);

    if(selected===r){
      ctx.strokeStyle="#facc15";
      ctx.lineWidth=2;
      ctx.stroke();
    }
  });
}

/* ===== CLICK ===== */
canvas.addEventListener("click",e=>{
  if(players[currentPlayer].ai) return;

  const x=(e.offsetX-transform.x)/transform.k;
  const y=(e.offsetY-transform.y)/transform.k;

  for(let r of regions){
    ctx.beginPath();
    path(r);
    if(ctx.isPointInPath(x,y)){
      const state=game.regions[r._name];

      if(!fromRegion){
        if(state.owner!==players[currentPlayer]) return;
        fromRegion=r;
        selected=r;
      }else{
        attack(fromRegion,r);
        fromRegion=null;
        selected=null;
      }

      info.innerHTML=`
        <b>${r._name}</b><br>
        Owner: ${state.owner.name}<br>
        Truppe: ${state.troops}<br>
        Turno: ${players[currentPlayer].name}
      `;
      draw();
      break;
    }
  }
});

/* ===== ATTACCO ===== */
function attack(from,to){
  if(from===to) return;

  const A=game.regions[from._name];
  const B=game.regions[to._name];

  if(!A.neighbors.includes(to._name)) return;
  if(A.troops<2) return;

  const atk=A.troops-1;
  const def=B.troops;

  if(atk>def){
    B.owner=A.owner;
    B.troops=atk-def;
  }else{
    B.troops-=atk;
  }
  A.troops=1;
}

/* ===== TURNI ===== */
endTurnBtn.onclick=()=>{
  currentPlayer=(currentPlayer+1)%players.length;
  reinforce();

  if(players[currentPlayer].ai){
    setTimeout(aiTurn,600);
  }
  info.textContent="Turno: "+players[currentPlayer].name;
  draw();
};

function reinforce(){
  for(let k in game.regions){
    if(game.regions[k].owner===players[currentPlayer]){
      game.regions[k].troops++;
    }
  }
}

/* ===== AI ===== */
function aiTurn(){
  for(let r of regions){
    const A=game.regions[r._name];
    if(A.owner!==players[currentPlayer]||A.troops<2) continue;

    for(let n of A.neighbors){
      const B=game.regions[n];
      if(B.owner!==A.owner){
        attack(r,regions.find(x=>x._name===n));
        break;
      }
    }
  }
  endTurnBtn.onclick();
}
</script>
</body>
</html>
